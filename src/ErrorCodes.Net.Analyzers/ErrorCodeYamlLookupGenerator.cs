using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace ErrorCodes.Net.Analyzers;

using DiagnosticErrors;
using Yaml.Converters;
using Yaml;

[Generator]
public class ErrorCodeYamlLookupGenerator : ISourceGenerator
{
    private int _productId = 0;
    
    public const string GENERATED_FILE_NAME = "ErrorCodeLookup.g.cs";
    
    /// <summary>
    /// Called before generation occurs. A generator can use the <paramref name="context" />
    /// to register callbacks required to perform generation.
    /// </summary>
    /// <param name="context">The <see cref="T:Microsoft.CodeAnalysis.GeneratorInitializationContext" /> to register callbacks on</param>
    public void Initialize(GeneratorInitializationContext context) { }

    /// <summary>
    /// Called to perform source generation. A generator can use the <paramref name="context" />
    /// to add source files via the <see cref="M:Microsoft.CodeAnalysis.GeneratorExecutionContext.AddSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)" />
    /// method.
    /// </summary>
    /// <param name="context">The <see cref="T:Microsoft.CodeAnalysis.GeneratorExecutionContext" /> to add source to</param>
    /// <remarks>
    /// This call represents the main generation step. It is called after a <see cref="T:Microsoft.CodeAnalysis.Compilation" /> is
    /// created that contains the user written code.
    /// A generator can use the <see cref="P:Microsoft.CodeAnalysis.GeneratorExecutionContext.Compilation" /> property to
    /// discover information about the users compilation and make decisions on what source to
    /// provide.
    /// </remarks>
    public void Execute(GeneratorExecutionContext context)
    {
        if(context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.ErrorCodesProductId", out var productIdValue))
        {
            int.TryParse(productIdValue, out _productId);
        }
        
        var yamlFile = context.AdditionalFiles.FirstOrDefault(f => f.Path.EndsWith("ErrorCodes.yaml") || f.Path.EndsWith("ErrorCodes.yml"));

        if (yamlFile is null)
        {
            return;
        }

        var content = yamlFile.GetText();
        
        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(CamelCaseNamingConvention.Instance)
            .WithTypeConverter(ExtensionDataTypeConverter.Instance)
            .Build();
            
        var errorCodeDefinitions = deserializer.Deserialize<ErrorTypeCollection>(content.ToString());

        if (string.IsNullOrEmpty(errorCodeDefinitions.Namespace))
        {
            context.ReportDiagnostic(Diagnostic.Create(YamlDiagnosticErrors.MissingNamespaceDescriptor,
                Location.Create(yamlFile.Path, new TextSpan(0, 0), new LinePositionSpan(LinePosition.Zero, LinePosition.Zero))));
            return;
        }

        string classesSection = CreateEnumClasses(errorCodeDefinitions);
        
         var result = $$"""
                // ------------------------------------------------------------------------------
                //  <auto-generated>
                //      This code was generated by ErrorCodes.Net.
                //
                //      Changes to this file may cause incorrect behavior and will be lost if
                //      the code is regenerated.
                //  </auto-generated>
                // ------------------------------------------------------------------------------
                #region Designer generated code
                #pragma warning disable
                using System.Collections.Generic;
                using ErrorCodes.Net;

                namespace {{errorCodeDefinitions.Namespace}}
                {

                {{classesSection}}
                    /// <summary>
                    /// Generated lookup class for error codes
                    /// </summary>
                    public static class ErrorCodeLookup
                    {
                {{CreateEnumLookupProperties(errorCodeDefinitions)}}
                    }
                }
                #pragma warning restore
                #endregion
                """;
         
         context.AddSource(GENERATED_FILE_NAME, SourceText.From(result, Encoding.UTF8, SourceHashAlgorithm.Sha256));
    }

    private string CreateEnumClasses(ErrorTypeCollection errorTypeCollection)
    {
        var enumClasses = new StringBuilder();

        foreach (var errorCodeDefinition in errorTypeCollection.ErrorTypes)
        {
            enumClasses.AppendLine(CreateEnumClass(errorCodeDefinition, errorTypeCollection.ProjectId));
        }

        return enumClasses.ToString();
    }
    
    private string CreateEnumClass(ErrorTypeDefinition errorTypeDefinition, uint projectId)
    {
        StringBuilder classStringBuilder = new StringBuilder();
        
        foreach (var errorCode in errorTypeDefinition.ErrorCodes)
        {
            string formattedValue = $"{_productId}x{projectId:X2}{errorTypeDefinition.ErrorTypeId:X2}{errorCode.ErrorCode:X4}";
            
            classStringBuilder.AppendLineIndented($"public ErrorCodeInfo {errorCode.Name} {{ get; }} = new ErrorCodeInfo(\"{formattedValue}\", {_productId}, {projectId}, {errorTypeDefinition.ErrorTypeId}, {errorCode.ErrorCode});", 2);
            classStringBuilder.AppendLine();
        }
        
        string classString = classStringBuilder.ToString().TrimEnd('\r', '\n');
        
        string summary = string.IsNullOrEmpty(errorTypeDefinition.Description) ? "Auto-generated class" : errorTypeDefinition.Description;
        
        return $$"""
                     /// <summary>
                     /// {{summary}}
                     /// </summary>
                     public class {{errorTypeDefinition.Name}}Errors
                     {
                 {{classString}}
                     }
                 """;
    }
    
    private string CreateEnumLookupProperties(ErrorTypeCollection errorTypeCollection)
    {
        StringBuilder propertiesStringBuilder = new StringBuilder();

        foreach (var enumSymbol in errorTypeCollection.ErrorTypes)
        {
            propertiesStringBuilder.AppendLineIndented($"public static {enumSymbol.Name}Errors {enumSymbol.Name} {{ get; }} = new {enumSymbol.Name}Errors();", 2);
            propertiesStringBuilder.AppendLine();
        }
            
        return propertiesStringBuilder.ToString();
    }
}
